/** \file tag_mesh.c
  * Sets size of the domain and mesh resolutions.
  *
  * This module updates global parameters and redefines macro-constants <b>mc_have_x,
  * mc_have_y, mc_have_z</b> if necessary (recompilation is necessary). To signal the
  * change of mc_have_x, .., mc_have_z signal file is created (signals and return code
  * sometimes do strange things under AIX and IRIX for older MPI implementations).
  *
  * Example of the config file entry is
    <pre>
    [mesh]
    @ 20		imax: mesh size along X axis
    @ 30		jmax: mesh size along Y axis
    @ 20		kmax: mesh size along Z axis
    @ 1.00e0		Lx:   domain size along X axis [micron]
    @ 1.50e0		Ly:   domain size along Y axis [micron]
    @ 1.00e0		Lz:   domain size along Z axis [micron]
    @ -0.8		tau:  time step; negative => unit is the biggest stable time step;
                	                 positive means that unit are default.
    </pre>
  *
  * Time step may be specified as an absolute value (almost never used though) or as a
  * fraction of the biggest stable time step for the Yee Maxwell solver.
  */

#include <math.h>
#include <stdlib.h>

#include <mpi.h>

#include "log.h"
#include "misc_units.h"
#include "misc_cfgReader.h"
#include "misc_parameters.h"

// ---------------------------------------------------------------------------
/// Gets parameters of the domain and sends it to the misc_parameters.c library.
// ---------------------------------------------------------------------------
void
tag_mesh (FILE *fp)
{
  int imax = cfg_readInt (fp),
      jmax = cfg_readInt (fp),
      kmax = cfg_readInt (fp);

  double Lx  = cfg_readDouble (fp)*units (mc_micron),				// Evaluates dimensionless steps (original
         Ly  = cfg_readDouble (fp)*units (mc_micron),				//   length units are microns).
         Lz  = cfg_readDouble (fp)*units (mc_micron),
         tau = cfg_readDouble (fp);

  imax -= (imax == 1);								// Mesh size <= 1 means no mesh in the direction.
  jmax -= (jmax == 1);
  kmax -= (kmax == 1);

  double h1 = Lx/(double) (imax + (imax == 0)),					// Defines spatial steps.
         h2 = Ly/(double) (jmax + (jmax == 0)),
         h3 = Lz/(double) (kmax + (kmax == 0));

  if (tau < 0)									// Converts tau from [tau_max] units.
    tau /= - sqrt (mc_have_x/(h1*h1) + mc_have_y/(h2*h2) + mc_have_z/(h3*h3));

  // Checks stability.
  ENSURE (tau*sqrt (mc_have_x/(h1*h1) + mc_have_y/(h2*h2) + mc_have_z/(h3*h3)) < 0.99,
          "tau (%le) is too big; h1 = %le, h2  = %le, h3 = %le; Courant = %e.",
          tau, h1, h2, h3, tau*sqrt (mc_have_x/(h1*h1) + mc_have_y/(h2*h2) + mc_have_z/(h3*h3)));

  // Checks if wavelength it resolved.
  // XXX TODO: set upper limit to '0.101'!
  ENSURE (h1*(imax > 0) < 0.2 && h2*(jmax > 0) < 0.2 && h3*(kmax > 0) < 0.2,
          "unresolved lambda: h1 = %le, h2  = %le, h3 = %le", h1, h2, h3);

  say ("tag_mesh:");
  say ("  - tau: %e [fs] (Courant parameter = %e)", tau/units (mc_femtosecond),
            tau*sqrt (mc_have_x/(h1*h1) + mc_have_y/(h2*h2) + mc_have_z/(h3*h3)));
  say ("  - mesh steps: %f x %f x %f [microns]", h1/units (mc_micron), h2/units (mc_micron), h3/units (mc_micron));

  // Checks if we need to update mc_have_x, mc_have_y, or mc_have_z.
  if ( (imax > 1) != mc_have_x || (jmax > 1) != mc_have_y || (kmax > 1) != mc_have_z)
  {
    // Master updates source file frame.h.
    if (! cpu_here)
    {
      FILE *frame = cfg_open ("source/frame.h", "wt", __func__);
      fprintf (frame, "/** \\file frame.h\n"
                      "  * Dimensionality (1D/2D/3D) configuration file.\n"
                      "  * File is automatically regenerated by [tag_mesh] handler.\n  */\n\n");
      fprintf (frame, "#ifndef mc_have_x\n\n");
      fprintf (frame, "#define  mc_have_x   %d\n", imax > 1);			// Writes new dimensionality flags.
      fprintf (frame, "#define  mc_have_y   %d\n", jmax > 1);
      fprintf (frame, "#define  mc_have_z   %d\n", kmax > 1);
      fprintf (frame, "\n#endif\n");
      fclose (frame);

      frame = cfg_open ("tmp/recompile", "wt", __func__);			// Makes signal-file for shell wrappers.
      fprintf (frame, "Recompile the code!\n");
      fclose (frame);
    }

    say ("\nDIMENSIONALITY IS CHANGED, PLEASE RECOMPILE THE CODE!\n");
    MPI_Barrier (MPI_COMM_WORLD);						// To avoid termination before root.
    exit (10);									// Terminates execution with exit code 10.
  }

  parameter_setupMesh (imax, jmax, kmax, Lx, Ly, Lz, tau);
  remove ("tmp/recompile");							// Removes signal file.
}
