/** \file IO_fileMap.c
  * \brief Mapping of the nodes on files in the ./binData.
  *
  * The goal is to work with filename patterns (format string for \b printf which holds all name specific stuff leaving '\%d'
  * for number of the record and '\%d' for the number of the node). Filemaps store only partitioning part of information: for
  * records with given number of record and number of node we can check if file is avaliable for access from the current node,
  * or who can access this file and so on. Implemented to support distributed file-systems (custom made clusters, high speed
  * access to the local scratch files and so on).
  *
  * Filemaps also contain partitioning of the domain, providing information for higher-level IO routines.
  *
  * Filemap files are saved, loaded and accessed the same way like all other incrementally numbered records:
  *  - internal counter stores number of the record;
  *  - counter is initialized in \b continue / \b start regime on start-up;
  *  - each \b save operation increases the counter.
  */

#include <stdlib.h>
#include <string.h>
#include <math.h>

#include <mpi.h>

#include "log.h"
#include "IO_names.h"
#include "IO_fileMap.h"

#include "misc_cfgReader.h"

/// Internal counters.
static int saveN = -1, mode = -1;

/// Name pattern for \b fileMap check-points.
static const char *name = "binData/fileMap_%06d.txt";

// ---------------------------------------------------------------------------
/// Initializes regime of the filemap generation (from setup (0), from core - start (1), from core - continue (2)).
// ---------------------------------------------------------------------------
void
fileMap_init (int startMode)
{
  FILE *fp;

  mode = -1;
  switch (startMode)
  {
    case mc_fileMap_setup:
      saveN = 0;
    break;

    case mc_fileMap_start:
      fp = cfg_open ("binData/fileMap_start.txt", "rt", __func__);
      saveN = cfg_readInt (fp);
      fclose (fp);
    break;

    case mc_fileMap_contn:
      fp = cfg_open ("binData/fileMap.N", "rt", __func__);
      saveN = cfg_readInt (fp);
      fclose (fp);
    break;

    default:
      DIE ("bad id of the start-up mode");
  }

  mode = startMode;													// Remembers mode of operation.
}

// ---------------------------------------------------------------------------
/// Deallocates filemap.
// ---------------------------------------------------------------------------
void
fileMap_free (fileMap_t *map)
{
  regList_clean (&map->map);
  if (map->visMatrix)
    free (map->visMatrix);
  map->visMatrix = NULL;
  map->cpu_total = 0;
}

// ---------------------------------------------------------------------------
/// \brief Builds visibility map for given pattern. Filename is generated by <b>sprintf (name, format, disk_nodeNumber)</b>.
// ---------------------------------------------------------------------------
void
fileMap_buildVisMatrix (fileMap_t *map, const char *format)
{
  if (map->visMatrix)													// Removes old map (if there are any).
  {
    free (map->visMatrix);
    map->visMatrix = NULL;
  }

  map->visMatrix = (int*) calloc (map->map.N*cpu_total, sizeof (int));							// Allocates clear visibility map.
  ENSURE (map->visMatrix,
          "out of memory (%.3f Kb)", map->map.N*cpu_total*sizeof (int)/1024.0);

  for (int cpu = 0 ; cpu < map->map.N ; ++cpu)										// Makes visibility line for each own node.
  {
    char name[80];
    sprintf (name, format, cpu);
    FILE *fp = fopen (name, "rb");
    if (fp)
    {
      map->visMatrix[cpu] = 1;
      fclose (fp);
    }
  }
  MPI_Gather (map->visMatrix, map->map.N, MPI_INT, map->visMatrix, map->map.N, MPI_INT, 0, MPI_COMM_WORLD);		// Assembles visibility matrix on master node.
  MPI_Bcast (map->visMatrix, map->map.N*cpu_total, MPI_INT, 0, MPI_COMM_WORLD);						// Master sends visibility map to all workers.
  map->cpu_total = cpu_total;
}

// ---------------------------------------------------------------------------
/// Checks if file for node \b node is readable from the node \b reader.
// ---------------------------------------------------------------------------
int
fileMap_readable (const fileMap_t *map, int node, int reader)
{
  if (!map->visMatrix || node < 0 || reader < 0 || node >= map->map.N || reader >= map->cpu_total)
    DIE ("bad parameters: data (%p), node (%d), reader (%d).", map->visMatrix, node, reader);
  return map->visMatrix[reader*map->map.N + node];
}

// ---------------------------------------------------------------------------
/// Saves file map and returns \b id to reference this record later (or to associate filemap with check-point).
// ---------------------------------------------------------------------------
int
fileMap_save (void)
{
  if (cpu_here)													// Only master saves map.
    return saveN;

  regList_t map = partition_getMapping ();
  FILE *fp = cfg_open (IO_nameRec (name, saveN), "wt", __func__);

  fprintf (fp, "%d cpus total.\n", map.N);
  for (reg_t *reg = map.list, *end = reg + map.N ; reg < end ; ++reg)
    fprintf (fp, "%d: (%d %d %d) - (%d %d %d)\n", reg->cpu, reg->min[0], reg->min[1], reg->min[2], reg->max[0], reg->max[1], reg->max[2]);
  fclose (fp);
  regList_clean (&map);
  saveN++;

  if (mode == mc_fileMap_setup)
  {
    fp = cfg_open ("binData/fileMap_start.txt", "wt", __func__);
    fprintf (fp, "@ %d filemaps are generated by setup - keep them on the start of simulation.\n", saveN);
    fclose (fp);
  }

  fp = cfg_open ("binData/fileMap.N", "wt", __func__);
  fprintf (fp, "@ %d filemaps total is written.\n", saveN);
  fclose (fp);

  return saveN - 1;
}

// ---------------------------------------------------------------------------
/// Loads file map referenced by \b id.
// ---------------------------------------------------------------------------
void
fileMap_load (fileMap_t *map, int id)
{
  fileMap_free (map);

  if (!cpu_here)
  {
    reg_t *reg;
    FILE *fp = cfg_open (IO_nameRec (name, id), "rt", __func__);
    fscanf (fp, "%d cpus total.\n", & map->map.N);
    reg = map->map.list = (reg_t*) malloc (map->map.N*sizeof (reg_t));
    for (const reg_t * const end = reg + map->map.N ; reg < end ; ++reg)
      fscanf (fp, "%d: (%d %d %d) - (%d %d %d)\n", &reg->cpu, &reg->min[0], &reg->min[1], &reg->min[2], &reg->max[0], &reg->max[1], &reg->max[2]);
    fclose (fp);
  }

  MPI_Bcast (& map->map.N, 1, MPI_INT, 0, MPI_COMM_WORLD);

  if (cpu_here)
    map->map.list = (reg_t*) malloc (map->map.N*sizeof (reg_t));

  MPI_Bcast (map->map.list, map->map.N*sizeof (reg_t), MPI_BYTE, 0, MPI_COMM_WORLD);
}
